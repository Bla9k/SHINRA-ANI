import { NextResponse } from 'next/server';
// Import specific functions from layers using ES6 syntax
import { fetchEpisodesFromAnimeSuge, fetchStreamingLinksFromAnimeSuge } from '@/layers/animesuge.js';
import { fetchEpisodesFromAniWave, fetchStreamingLinksFromAniWave } from '@/layers/aniwave.js';
// Import other layers if needed (assuming allanime and animedao use CommonJS or are refactored)
// const allanime = require('@/layers/allanime'); // Example if still CommonJS
// const animedao = require('@/layers/animedao'); // Example if still CommonJS

// Helper to resolve potentially nested streaming URLs (e.g., from Vidplay/MyCloud)
// Placeholder - This requires a separate resolver implementation
async function resolveStreamUrl(iframeUrl: string): Promise<{ url: string; quality?: string; } | null> {
  console.log(`[resolveStreamUrl] Attempting to resolve: ${iframeUrl}`);
  // TODO: Implement logic to fetch the iframe URL and scrape/decode the actual stream link (e.g., .m3u8)
  // This might involve finding specific script variables or making further AJAX calls.
  // Example for common players might involve checking hostname and calling specific resolvers.
  // if (iframeUrl.includes('vidplay')) { return resolveVidplay(iframeUrl); }
  // if (iframeUrl.includes('mycloud')) { return resolveMyCloud(iframeUrl); }
  console.warn(`[resolveStreamUrl] Resolution logic not implemented for: ${iframeUrl}`);
  // For now, return the iframe URL itself, but mark it as unresolved/low quality
  return { url: iframeUrl, quality: 'iframe' };
}


/**
 * Handles GET requests for streaming links using multiple scraping layers as fallbacks.
 *
 * @param request The incoming request.
 * @param params The dynamic parameters from the URL, containing the anime ID (id) and episode ID (episodeId).
 *               The episodeId is the unique identifier generated by the episode fetching layer.
 * @returns A NextResponse with the streaming data or an error.
 */
export async function GET(
    request: Request,
    { params }: { params: { id: string; episodeId: string } }
) {
    const { id: animeMalId, episodeId } = params; // Rename id for clarity

    // Extract source and episode number from the combined episodeId if necessary
    // Example: episodeId = "AnimeTitle-ep-1" -> title="AnimeTitle", number=1
    // This depends on how you generate the ID in the episode fetching layers.
    // Let's assume for now episodeId directly maps to the info needed by the streaming link fetcher.
    // A better approach is to pass source and link/internal ID from the frontend.

    // For now, we'll assume the frontend needs to tell us which source/link to use,
    // maybe by passing it in the query params or modifying the episodeId format.
    // Let's modify this route to expect source and the *actual* episode link/ID from that source.
    // New URL structure idea: /api/stream?source=AnimeSuge&link=https://animesuge.../ep-1
    // Or pass source and episode ID: /api/stream?source=AnimeSuge&episodeId=unique-ep-id

    const searchParams = new URL(request.url).searchParams;
    const source = searchParams.get('source');
    const episodeLink = searchParams.get('link'); // The link from the specific provider's episode list
    const episodeNumber = searchParams.get('number'); // Optional, for logging

    if (!source || !episodeLink) {
        return NextResponse.json({ message: 'Missing source or episode link query parameter' }, { status: 400 });
    }

    console.log(`[API/stream] Received request for Source: ${source}, Episode Link: ${episodeLink}, Episode Num: ${episodeNumber}`);

    let streamUrl: string | null = null;
    let resolvedStreamData: { url: string; quality?: string; } | null = null;

    try {
        // Construct episodeData object based on the source and link
        const episodeData = { link: episodeLink, source: source, number: episodeNumber };

        // --- Attempt fetching streaming link based on the source ---
        switch (source) {
            // case 'AllAnime':
            //     const allanimeLayer = await import('@/layers/allanime.js');
            //     streamUrl = await allanimeLayer.fetchStreamingLinksFromAllAnime(episodeData);
            //     break;
            case 'AnimeSuge':
                streamUrl = await fetchStreamingLinksFromAnimeSuge(episodeData);
                break;
            // case 'AnimeDao':
            //      const animedaoLayer = await import('@/layers/animedao.js');
            //     streamUrl = await animedaoLayer.fetchStreamingLinksFromAnimeDao(episodeData);
            //     break;
            case 'AniWave':
                streamUrl = await fetchStreamingLinksFromAniWave(episodeData);
                break;
            default:
                console.warn(`[API/stream] Unsupported source provided: ${source}`);
                return NextResponse.json({ message: `Unsupported source: ${source}` }, { status: 400 });
        }

        if (!streamUrl) {
            console.warn(`[API/stream] Failed to fetch initial stream URL from ${source} for link: ${episodeLink}`);
            return NextResponse.json({ message: `Could not find streaming link on ${source}.` }, { status: 404 });
        }

        console.log(`[API/stream] Initial stream URL from ${source}: ${streamUrl}`);

        // --- Attempt to resolve the URL if it's an iframe/player page ---
        resolvedStreamData = await resolveStreamUrl(streamUrl);

        if (!resolvedStreamData || !resolvedStreamData.url) {
            console.warn(`[API/stream] Failed to resolve the final stream URL from: ${streamUrl}`);
            // Fallback: Return the unresolved URL but maybe flag it
            return NextResponse.json({ url: streamUrl, quality: 'iframe/unresolved', message: 'Could not resolve final stream link.' }, { status: 200 }); // Return 200 but indicate issue
        }

        console.log(`[API/stream] Resolved stream data: Quality=${resolvedStreamData.quality}, URL=${resolvedStreamData.url}`);
        // Return the best quality URL found
        return NextResponse.json({ url: resolvedStreamData.url, quality: resolvedStreamData.quality || 'unknown' });

    } catch (error: any) {
        console.error(`[API/stream] Error processing stream request for ${source} - ${episodeLink}:`, error);
        return NextResponse.json({ message: 'Internal server error while fetching stream.', error: error.message }, { status: 500 });
    }
}
